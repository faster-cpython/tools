#!/usr/bin/env python3.12

"""Symbolic execution, hero style. :-)

Inspired by mark_stacks() in Python/frameobject.c.
"""

from __future__ import annotations

import dis
import os
import re
import types
from typing import Any

import forallcode

opcode_metadata: dict[str, dict[str, Any]]
from opcode_metadata import opcode_metadata  # Generated by cases_generator.py

# TODO: Special-case this in update_stack() instead.
opcode_metadata["COMPARE_AND_BRANCH"]["pushed"] = lambda oparg, jump: 1


# Copied from Include/cpython/code.h
CO_COROUTINE = 0x0080
CO_GENERATOR = 0x0020
CO_ASYNC_GENERATOR = 0x0200

# Symbolic values on the stack
OBJECT = "Obj"
LASTI = "LastI"
EXCEPTION = "Exc"


Stack = tuple[str, ...]


class Instruction:
    # TODO: __slots__?
    opcode: int
    opname: str
    oparg: int | None
    baseopname: str
    baseopcode: int
    # Offsets in bytes, not code words!
    start_offset: int
    cache_offset: int
    end_offset: int
    jump_target: int | None
    is_jump_target: bool

    def __init__(self, opcode: int, oparg: int, start_offset: int, cache_offset: int):
        self.opcode = opcode
        self.opname = dis.opname[opcode]
        self.oparg = oparg if opcode >= dis.HAVE_ARGUMENT else None
        self.baseopname = dis.deoptmap.get(self.opname, self.opname)
        self.baseopcode = dis.opmap[self.baseopname]
        self.start_offset = start_offset
        self.cache_offset = cache_offset
        self.end_offset = cache_offset + 2 * dis._inline_cache_entries[opcode]
        self.jump_target = None
        assert not dis.hasjabs
        if self.baseopcode in dis.hasjrel:
            if self.baseopname in ("JUMP_BACKWARD", "JUMP_BACKWARD_NO_INTERRUPT"):
                oparg = -oparg
            self.jump_target = self.end_offset + 2 * oparg
        self.is_jump_target = False  # Filled in by parse_bytecode()

    def __repr__(self):
        return f"Instruction{self.__dict__}"

    def __str__(self):
        prefix = ">>" if self.is_jump_target else "  "
        if self.oparg is None:
            soparg = ""
        else:
            soparg = f" {self.oparg:{max(1, 20 - len(self.opname))}d}"
            if self.jump_target:
                soparg += f" (to {self.jump_target})"
        return f"{prefix} {self.start_offset:3d} {self.opname}{soparg}"

    def successors(self: Instruction) -> list[int | None]:
        """Return a list of successor offsets.

        An offset is either None (fall through to the next instruction) or
        an int (jump to the instruction at that offset, in absolute bytes).

        A "normal" instruction, e.g. LOAD_FAST, returns [None].
        An unconditional jump, e.g. JUMP_BACKWARD, returns [offset].
        A conditional jump, e.g. POP_JUMP_IF_TRUE, returns [None, offset].
        An instruction that only exits, e.g. RETURN_VALUE, returns [].
        """
        if self.opname in ("RETURN_VALUE", "RETURN_CONST", "RERAISE", "RAISE_VARARGS"):
            return []
        assert not dis.hasjabs
        if self.baseopcode not in dis.hasjrel:
            # TODO: Other instructions that have a jump option
            return [None]
        arg = self.oparg
        assert arg is not None
        if self.baseopname in ("JUMP_BACKWARD", "JUMP_BACKWARD_NO_INTERRUPT"):
            # Unconditional jump backwards
            return [self.end_offset - 2 * arg]
        if self.baseopname == "JUMP_FORWARD":
            # Unconditional jump forwards
            return [self.end_offset + 2 * arg]
        # Conditional jump forwards
        return [None, self.end_offset + 2 * arg]

    def update_stack(self, input: Stack, verbose: int) -> list[tuple[int, Stack]]:
        """Return a list of (int, Stack) pairs corresponding to self.successors().

        If the instruction never jumps, return [(self.end_offset, new_stack)].
        If it always jumps, return [(self.jump_target, new_stack)].
        If it may or may not jump, return [(self.end_offset, new_stack1), (self.jump_target, new_stack2)].
        If it always exits, return [].
        """
        result: list[tuple[int, Stack]] = []
        for offset in self.successors():
            jump = offset is not None
            if offset is None:
                offset = self.end_offset
            stack = list(input)
            metadata = opcode_metadata[self.baseopname]
            popped: int = metadata["popped"](self.oparg, jump)
            pushed: int = metadata["pushed"](self.oparg, jump)
            if verbose >= 2:
                print(f"  {popped=} {pushed=}")
            assert popped >= 0 and pushed >= 0, (popped, pushed)
            if len(stack) < popped:
                breakpoint()
                assert False, "stack underflow"
                popped = len(stack)
            input_effects = list(metadata.get("input_effects") or ())
            output_effects = list(metadata.get("output_effects") or ())
            while (
                popped > 0
                and pushed > 0
                and input_effects
                and output_effects
                and input_effects[0] == output_effects[0]
                and input_effects[0][1:] == ("", "", "")
            ):
                if verbose >= 2:
                    print("REDUCING EFFECT", input_effects[0], "for", self.opname)
                pushed -= 1
                popped -= 1
                input_effects.pop(0)
                output_effects.pop(0)
            del stack[len(stack) - popped :]
            stack += [OBJECT] * pushed
            if verbose >= 2:
                print(f"  {offset=} {stack=}")
            result.append((offset, tuple(stack)))
        return result


def parse_bytecode(co: bytes) -> list[Instruction]:
    result: list[Instruction] = []
    i = 0
    n = len(co)
    assert n % 2 == 0
    while i < n:
        start_offset = i
        opcode = co[i]
        oparg = co[i + 1]
        i += 2
        while opcode == dis.EXTENDED_ARG:
            opcode = co[i]
            oparg = oparg << 8 | co[i + 1]
            i += 2
        cache_offset = i
        instr = Instruction(opcode, oparg, start_offset, cache_offset)
        i = instr.end_offset
        result.append(instr)
    for instr in result:
        if instr.jump_target is not None:
            for target in result:
                if target.start_offset == instr.jump_target:
                    target.is_jump_target = True
                    break
            else:
                assert False, f"Invalid jump target {instr.jump_target}"

    return result


class Execution:
    code: types.CodeType
    verbose: int
    instrs: list[Instruction]
    instrs_by_offset: dict[int, Instruction]
    stacks: dict[Instruction, Stack | None]
    debug: dict[Instruction, Instruction | str]
    etab: list[tuple[int, int, int, int, int]]
    rev_etab: dict[Instruction, tuple[int, int, int, int, int]]

    def __init__(self, code: types.CodeType, verbose: int = 0):
        self.code = code
        self.verbose = verbose
        self.instrs = parse_bytecode(code.co_code)
        self.instrs_by_offset = {b.start_offset: b for b in self.instrs}
        self.stacks = {}
        self.debug = {}
        self.etab = []
        self.rev_etab = {}

    def init_stacks(self):
        self.stacks = {b: None for b in self.instrs}
        # Initialize stacks with known contents:
        # - The stack at the start of a regular function is empty.
        # - The stack at the start of a generator(-ish) function is (OBJECT,).
        # - The stack at the start of each exception handler is known.
        first = self.instrs[0]
        self.debug[first] = "FIRST"
        if self.code.co_flags & (CO_COROUTINE | CO_GENERATOR | CO_ASYNC_GENERATOR):
            self.stacks[first] = (OBJECT,)
        else:
            self.stacks[first] = ()

    def setup_handlers(self):
        self.rev_etab = {}
        self.etab = dis._parse_exception_table(self.code)
        for start, end, target, depth, lasti in self.etab:
            if self.verbose >= 1:
                print(
                    f"ETAB: [{start:3d} {end:3d}) -> {target:3d} {depth} {'lasti' if lasti else ''}"
                )
            b = self.instrs_by_offset[target]
            b.is_jump_target = True
            self.rev_etab[b] = start, end, target, depth, lasti

    def run(self):
        self.init_stacks()
        self.setup_handlers()

        # Repeatedly propagate stack contents until a fixed point is reached.
        while True:
            if not self.propagate_stacks():
                break
            # I have not found any cases that need more than one iteration.
            assert False, f"We need another iteration after all: {code}"

    def propagate_stacks(self) -> bool:
        if self.verbose >= 1:
            print("=" * 50)
        todo = False
        for b in self.instrs:
            stack = self.stacks[b]
            if stack is None and b in self.rev_etab:
                start, end, target, depth, lasti = self.rev_etab[b]
                bb = self.instrs_by_offset.get(start)
                if bb is not None:
                    stack = self.stacks[bb]
                    if stack is not None:
                        stack = stack[:depth]
                        if lasti:
                            stack += (LASTI,)
                        stack += ("Exception",)
                        self.stacks[b] = stack
            if self.verbose >= 1:
                if b in self.rev_etab:
                    print("HANDLER:", self.rev_etab[b])
                print(b, stack)
            if stack is None:
                continue
            updates = b.update_stack(stack, self.verbose)
            for offset, new_stack in updates:
                bb = self.instrs_by_offset[offset]
                if self.verbose >= 1:
                    if offset == b.end_offset:
                        print(f"    Fall through {new_stack}")
                    else:
                        print(f"    Jump to {bb} {new_stack}")
                if self.stacks[bb] is None:
                    self.stacks[bb] = new_stack
                    self.debug[bb] = b
                    if offset < b.end_offset:
                        todo = True
                else:
                    if self.stacks[bb] != new_stack:
                        print(f"MISMATCH AT {offset}: {self.stacks[bb]} != {new_stack}")
                        print(f"FROM {self.debug.get(bb)}")
                        breakpoint()
                        assert False, "mismatch"
            if self.verbose >= 1:
                if not any(offset is not None for offset, _ in updates):
                    print("-" * 40)
        return todo

    def report_unreachable_instructions(self):
        unreachable = [b for b, stack in self.stacks.items() if stack is None]
        if unreachable:
            print("Unreachable instructions in", self.code)
            for b in unreachable:
                print(f"UNREACHED: {b.start_offset} {b.opname} {b.oparg}")

    def report_end_state(self):
        print("Execution report for", self.code)

        max_stack_size = 4  # len(str(None))
        for stack in self.stacks.values():
            if stack:
                max_stack_size = max(max_stack_size, len(str(stack)))

        try:
            limit = min(max_stack_size, os.get_terminal_size().columns - 40)
        except OSError:
            limit = 80

        # Format what we found nicely.
        for b in self.instrs:
            if b in self.rev_etab:
                print("HANDLER:", self.rev_etab[b])
            stack = self.stacks.get(b)
            if stack is not None:
                stack = list(stack)
            sstack = str(stack)
            if len(sstack) <= limit:
                print(f"{sstack:<{limit}s} {b}")
            else:
                print(f"{sstack}")
                print(f" {' '*limit}{b}")
            if None not in b.successors():
                print("-" * 40)


def run(code: types.CodeType, verbose: int):
    exe = Execution(code, verbose - 1)
    exe.run()
    if verbose >= 0:
        exe.report_unreachable_instructions()
    if verbose >= 1:
        exe.report_end_state()


def main():
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--verbose", action="count", help="More debug output")
    parser.add_argument("-q", "--quiet", action="count", help="Less debug output")
    parser.add_argument(
        "-m",
        "--match",
        help="Only process functions matching this regex",
        action="append",
    )
    parser.add_argument(
        "-x", "--exclude", help="Skip functions matching this regex", action="append"
    )
    parser.add_argument(
        "path", nargs="*", help="One or more files, tarballs or directories"
    )
    args = parser.parse_args()

    verbose = (args.verbose or 0) - (args.quiet or 0)
    match = "|".join(args.match) if args.match else None
    exclude = "|".join(args.exclude) if args.exclude else None
    if args.path:
        for code in forallcode.find_all_code(args.path, min(verbose + 1, 1)):
            tags = f"{code.co_filename}:{code.co_name}"
            if match and not re.search(match, tags):
                continue
            if exclude and re.search(exclude, tags):
                continue
            if verbose >= 1:
                print("Processing", code)
                if verbose >= 2:
                    dis.dis(code, adaptive=True, depth=0, show_caches=False)
            run(code, verbose)
    else:
        if verbose >= 0:
            print("Processing sample.test")
        from sample import test

        if verbose >= 2:
            dis.dis(test, adaptive=True, depth=0, show_caches=False)
        run(test.__code__, verbose)


if __name__ == "__main__":
    main()
