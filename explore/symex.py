# Symbolic execution, hero style. :-)

import dis
from typing import Callable

import opcode_metadata  # Generated by cases_generator.py


def nope(arg):
    pass


def test(a, b):
    for i in range(3):
        nope(a*i + b)


test(2, 4)

dis.dis(test, adaptive=True)

"""
  6           0 RESUME                   0

  7           2 LOAD_GLOBAL              1 (NULL + range)
             14 LOAD_CONST               1 (10)
             16 CALL                     1
             26 GET_ITER
        >>   28 FOR_ITER_RANGE          21 (to 74)
             32 STORE_FAST               2 (i)

  8          34 LOAD_GLOBAL_BUILTIN      3 (NULL + nope)
             46 LOAD_FAST__LOAD_FAST     0 (a)
             48 LOAD_FAST                2 (i)
             50 BINARY_OP_MULTIPLY_INT     5 (*)
             54 LOAD_FAST                1 (b)
             56 BINARY_OP_ADD_INT        0 (+)
             60 CALL_BUILTIN_FAST_WITH_KEYWORDS     1
             70 POP_TOP
             72 JUMP_BACKWARD           23 (to 28)

  7     >>   74 END_FOR
             76 RETURN_CONST             0 (None)
"""


Stack = tuple[str, ...]

def update_stack(input: Stack, b: dis.Instruction) -> tuple[Stack|None, Stack|None]:
    """Return a pair of optional Stacks.

    If the instruction never jumps, return (Stack, None).
    If it always jumps, return (None, Stack).
    If it may or may not jump, return (StackIfNotJumping, StackIfJumping).
    """
    succ = successors(b)
    if succ == None:
        jumps = [0, None]
    else:
        fallthrough, _ = succ
        if fallthrough:
            jumps = [0, 1]
        else:
            jumps = [None, 1]
    stacks: list[Stack|None] = []
    for jump in jumps:
        if jump is None:
            stacks.append(None)
            continue
        stack = list(input)
        baseopname: str = dis.deoptmap.get(b.opname, b.opname)
        metadata: dict|None = opcode_metadata.opcode_metadata[baseopname]
        popped = metadata["popped"](b.arg, jump)
        pushed = metadata["pushed"](b.arg, jump)
        # print(stack, b.opname, popped, pushed)
        assert popped >= 0 and pushed >= 0, (popped, pushed)
        if len(stack) < popped:
            breakpoint()
            assert False, "stack underflow"
        stack = stack[:len(stack) - popped]
        stack = stack + ["object"] * pushed
        stacks.append(tuple(stack))
    assert len(stacks) == 2
    return tuple(stacks)


def successors(b: dis.Instruction) -> None | tuple[bool, int]:
    baseopname = dis.deoptmap.get(b.opname, b.opname)
    baseopcode = dis.opmap[baseopname]
    assert not dis.hasjabs
    if baseopcode not in dis.hasjrel:
        return None
    fallthrough = True
    arg = b.arg
    if baseopname == "JUMP_BACKWARD":
        arg = -arg
        fallthrough = False
    instr_size = 1 + dis._inline_cache_entries[baseopcode]
    return fallthrough, b.offset + 2*arg + 2*instr_size


def run(func: Callable[..., object]):
    instrs: list[dis.Instruction] = list(dis.Bytecode(func, adaptive=True))
    assert instrs != []
    stacks: dict[dis.Instruction, Stack | None] = {b: None for b in instrs}
    stacks[instrs[0]] = ()
    todo = True
    while todo:
        todo = False
        stack = None
        for b in instrs:
            if stack is not None:
                if stacks[b] is None:
                    stacks[b] = stack
                    todo = True
                else:
                    if stacks[b] != stack:
                        print(f"MISMATCH at {b.offset}: {stacks[b]} != {stack}")
            else:
                stack = stacks[b]
                if stack is None:
                    continue
            stack_if_no_jump, stack_if_jump = update_stack(stack, b)
            jumps = successors(b)
            if jumps is not None:
                fallthrough, offset = jumps
                # print(b.opname, "JUMP DATA:", fallthrough, offset)
                stack = stack_if_jump
                for bb in instrs:
                    if bb.offset == offset:
                        # print("  TO:", bb.opname, "AT", bb.offset)
                        if stacks[bb] is None:
                            stacks[bb] = stack
                            todo = True
                        else:
                            if stacks[bb] != stack:
                                print(f"MISMATCH AT {offset}: {stacks[bb]} != {stack}")
                        break
                else:
                    print(f"CANNOT FIND {offset} for {stack}")
            stack = stack_if_no_jump
        # if stack is not None:
        #     print(f"End: {stack}")

    for b in instrs:
        stack = stacks.get(b)
        if stack is not None:
            stack = list(stack)
        print(str(stack).ljust(50), b.opname, b.arg if b.arg is not None else "")


run(test)
