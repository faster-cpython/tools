#!/usr/bin/env python3.12

"""Symbolic execution, hero style. :-)"""

import dis
from typing import Any, Callable, Iterable

opcode_metadata: dict[str, dict[str, Any]]
from opcode_metadata import opcode_metadata  # Generated by cases_generator.py


def nope(arg):
    pass


def test(a, b):
    for i in range(3):
        nope(a*i + b)


test(2, 4)

dis.dis(test, adaptive=True)

"""
  6           0 RESUME                   0

  7           2 LOAD_GLOBAL              1 (NULL + range)
             14 LOAD_CONST               1 (10)
             16 CALL                     1
             26 GET_ITER
        >>   28 FOR_ITER_RANGE          21 (to 74)
             32 STORE_FAST               2 (i)

  8          34 LOAD_GLOBAL_BUILTIN      3 (NULL + nope)
             46 LOAD_FAST__LOAD_FAST     0 (a)
             48 LOAD_FAST                2 (i)
             50 BINARY_OP_MULTIPLY_INT     5 (*)
             54 LOAD_FAST                1 (b)
             56 BINARY_OP_ADD_INT        0 (+)
             60 CALL_BUILTIN_FAST_WITH_KEYWORDS     1
             70 POP_TOP
             72 JUMP_BACKWARD           23 (to 28)

  7     >>   74 END_FOR
             76 RETURN_CONST             0 (None)
"""


class Instruction:
    # TODO: __slots__?
    opcode: int
    opname: str
    oparg: int | None
    baseopname: str
    baseopcode: int
    # Offsets in bytes, not code words!
    start_offset: int
    cache_offset: int
    end_offset: int

    def __init__(self, opcode: int, oparg: int, start_offset: int, cache_offset: int):
        self.opcode = opcode
        self.opname = dis.opname[opcode]
        self.oparg = oparg if opcode >= dis.HAVE_ARGUMENT else None
        self.baseopname = dis.deoptmap.get(self.opname, self.opname)
        self.baseopcode = dis.opmap[self.baseopname]
        self.start_offset = start_offset
        self.cache_offset = cache_offset
        self.end_offset = cache_offset + 2 * dis._inline_cache_entries[opcode]


def parse_bytecode(co: bytes) -> Iterable[Instruction]:
    i = 0
    n = len(co)
    assert n % 2 == 0
    while i < n:
        start_offset = i
        opcode = co[i]
        oparg = co[i + 1]
        i += 2
        while opcode == dis.EXTENDED_ARG:
            opcode = co[i]
            oparg = oparg << 8 | co[i + 1]
            i += 2
        cache_offset = i
        instr = Instruction(opcode, oparg, start_offset, cache_offset)
        i = instr.end_offset
        yield instr


Stack = tuple[str, ...]

def update_stack(input: Stack, b: Instruction) -> tuple[Stack|None, Stack|None]:
    """Return a pair of optional Stacks.

    If the instruction never jumps, return (Stack, None).
    If it always jumps, return (None, Stack).
    If it may or may not jump, return (StackIfNotJumping, StackIfJumping).
    """
    succ = successors(b)
    if succ == None:
        jumps = [0, None]
    else:
        fallthrough, _ = succ
        if fallthrough:
            jumps = [0, 1]
        else:
            jumps = [None, 1]
    stacks: list[Stack|None] = []
    for jump in jumps:
        if jump is None:
            stacks.append(None)
            continue
        stack = list(input)
        metadata: dict|None = opcode_metadata[b.baseopname]
        popped: int = metadata["popped"](b.oparg, jump)
        pushed: int = metadata["pushed"](b.oparg, jump)
        # print(stack, b.opname, popped, pushed)
        assert popped >= 0 and pushed >= 0, (popped, pushed)
        if len(stack) < popped:
            breakpoint()
            assert False, "stack underflow"
        stack = stack[:len(stack) - popped]
        stack = stack + ["object"] * pushed
        stacks.append(tuple(stack))
    assert len(stacks) == 2
    return tuple(stacks)


def successors(b: Instruction) -> None | tuple[bool, int]:
    assert not dis.hasjabs
    if b.baseopcode not in dis.hasjrel:
        return None
    fallthrough = True
    arg = b.oparg
    assert arg is not None
    if b.baseopname == "JUMP_BACKWARD":
        arg = -arg
        fallthrough = False
    return fallthrough, b.end_offset + 2*arg


def run(func: Callable[..., object]):
    instrs: list[Instruction] = list(parse_bytecode(func.__code__.co_code))
    assert instrs != []
    stacks: dict[Instruction, Stack | None] = {b: None for b in instrs}
    stacks[instrs[0]] = ()
    todo = True
    while todo:
        todo = False
        stack = None
        for b in instrs:
            if stack is not None:
                if stacks[b] is None:
                    stacks[b] = stack
                    todo = True
                else:
                    if stacks[b] != stack:
                        print(f"MISMATCH at {b.start_offset}: {stacks[b]} != {stack}")
            else:
                stack = stacks[b]
                if stack is None:
                    continue
            stack_if_no_jump, stack_if_jump = update_stack(stack, b)
            jumps = successors(b)
            if jumps is not None:
                fallthrough, offset = jumps
                # print(b.opname, "JUMP DATA:", fallthrough, offset)
                stack = stack_if_jump
                for bb in instrs:
                    if bb.start_offset == offset:
                        # print("  TO:", bb.opname, "AT", bb.offset)
                        if stacks[bb] is None:
                            stacks[bb] = stack
                            todo = True
                        else:
                            if stacks[bb] != stack:
                                print(f"MISMATCH AT {offset}: {stacks[bb]} != {stack}")
                        break
                else:
                    print(f"CANNOT FIND {offset} for {stack}")
            stack = stack_if_no_jump
        # if stack is not None:
        #     print(f"End: {stack}")

    for b in instrs:
        stack = stacks.get(b)
        if stack is not None:
            stack = list(stack)
        print(str(stack).ljust(50), b.opname, b.oparg if b.oparg is not None else "")


run(test)
